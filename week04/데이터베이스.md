# 데이터베이스

## 1. 데이터베이스의 기본

- 데이터베이스 : 일정한 규칙, 혹은 규약을 통해 구조화되어 저장되는 데이터의 모음
- DBMS : 데이터베이스를 제어, 관리하는 통합 시스템
- 쿼리 : DBMS마다 정의된 언어

### 엔티티

여러 개의 속성을 지닌 명사

ex) 회원 엔티티 - 이름, 아이디, 주소, 전화번호… 

- 약한 엔티티 : 다른 엔티티의 존재 여부에 따라 종속적
- 강한 엔티티 : 혼자서도 존재 가능

### 릴레이션

데이터베이스에서 정보를 구분하여 저장하는 기본 단위

- 관계형 DB
    - ex) MySQL
    - 릴레이션 = table
    - 구조 : 레코드-테이블-데이터베이스
- NoSQL DB
    - ex) MongoDB
    - 릴레이션 = 컬렉션
    - 구조 : 도큐먼트 - 컬렉션 - 데이터베이스

### 속성

릴레이션에서 관리하는 구체적이며 고유한 이름을 갖는 정보

ex) 차 넘버, 바퀴 수, 차 색깔, 차종…

- 관리해야 할 필요가 있는 속성들만 엔터티의 속성

### 도메인

속성들이 가질 수 있는 값의 집합

ex) 성별 속성 - {남,여}

### 필드와 레코드

테이블 구성 - 필드, 레코드

- 필드
    - ex) name, ID, address - 엔티티의 속성
    - 숫자타입, 날짜타입, 문자타입
    - ENUM : 문자열 열거한 타입, 단일선택
    - SET : 문자열 열거한 타입, 여러개 데이터 선택, 비트 단위 연산
- 레코드, 튜플
    - 필드에 해당하는 데이터들

### 관계

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/ee70d5a1-e5e7-4549-a4aa-ffe47c4c2550/Untitled.png)

- 1:1 관계
    
    ex) 유저-이메일
    
    - 한유저는 하나의 이메일만 등록
- 1:N 관계
    
    ex) 유저-상품
    
    - 한유저가 여러 상품 고를 수 있음
    - 0개 상품 선택도 가능하면 0도 표현
- N:M 관계
    
    ex) 학생-강의
    
    - 한 학생이 여러 강의 들을 수 있음
    - 한 강의도 여러 학생이 들을 수 있음
    - 학생-강의 테이블 넣음 (1:N, 1:M 간접적 연결)
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/b42c860a-c10e-40e1-95ab-cb7de2f197d8/Untitled.png)
    

### 키

최소성 : 필드 조합하지 않고 최소 필드만으로 키 형성 가능한 것

유일성 : 중복되는 값 없는 것

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/adf40a32-4b01-4048-893c-8ee29e744ffc/Untitled.png)

- 기본키
    - PK
    - 유일성, 최소성
    - 테이블의 데이터중 고유하게 존재
- 자연키
    - 중복되지 않은 값
    - 언젠가는 변함
    - ex) 주민번호
- 인조키
    - 인위적으로 고유 식별자 만들기
    - 변하지 않음 → 주로 PK
    - ex) 아이디(고유성 부여)
- 외래키
    - 다른 테이블의 PK 참조
    - 중복 가능
- 후보키
    - 기본키가 될 수 있는 후보
    - 유일성, 최소성
- 대체키
    - 후보키 두개 일때 기본키 제외한 키
- 슈퍼키
    - 레코드 식별할 수 있게 유일성 갖춘 키

## 2. ERD와 정규화 과정

ERD : 릴레이션 간의 관계들을 정의한것

### 정규화 원칙

릴레이션을 

- 좀 더 좋은 구조로
- 자료의 중복성 감소
- 독립적인 관계는 별개의 릴레이션으로 표현
- 각각의 릴레이션은 독립적인 표현이 가능하도록

### 제1정규형

릴레이션의 모든 도메인이 더 이상 분해될 수 없는 원자 값만으로 구성

- 반복집합 제거
    - 속성 값 중에서 한 개의 기본키에 대해 두 개 이상의 값을 가지는 것

### 제2정규형

릴레이션이 제1정규형이며 부분 함수의 종속성을 제거한 형태

- 기본키가 아닌 모든 속성이 기본키에 완전 함수 종속적인 것
- 릴레이션을 분해 → 동등한 릴레이션으로 분해, 무손실분해

### 제3정규형

제2정규형이고 기본키가 아닌 모든 속성이 이행적 함수 종속을 만족하지 않는 상태

- 이행적 함수 종속
    - A→B, B→C ⇒ A→C
    - C가 A에 이행적으로 함수종속이 되었다

## 3. 트랜잭션과 무결성

### 트랜잭션

데이터베이스에서 하나의 논리적 기능을 수행하기 위한 작업의 단위

= 여러 개의 쿼리들을 하나로 묶는 단위

### ACID 특징

1. 원자성
    
    트랜잭션과 관련된 일이 모두 수행되었거나 되지 않았거나를 보장하는 특징				
    
    - 커밋
        - 쿼리가 성공적으로 처리되었다고 확정하는 명령어
        - 트랜잭션 단위로 수행
        - 변경된 내용이 모두 영구적으로 저장되는 것
        - update-insert-delete-DB영구저장
    - 롤백
        - 트랜잭션으로 처리한 하나의 묶음 과정을 일어나기 전으로 돌리는 일
    - 롤백, 커밋으로 데이터 무결성 보장
2. 일관성
    
    ‘허용된 방식’으로만 데이터를 변경해야 하는 것
    
    - 기록된 모든 데이터는 여러 가지 조건, 규칙에 따라 유효함을 가져야 함
3. 격리성
    
    트랜잭션 수행 시 서로 끼어들지 못하는 것
    
    - 복수의 병렬 트랜잭션 → 서로 격리되어 순차적으로 실행되는 것처럼 작동
    - 데이터베이스는 여러 사용자가 같은 데이터에 접근할 수 있어야 함
    - 그냥 순차적 x , 여러 개의 격리 수준으로 나뉘어 격리성을 보장
    
    ![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/80cee9f7-fa2c-4bb5-82ad-52734486e9ef/Untitled.png)
    

1. 지속성
    
    성공적으로 수행된 트랜잭션은 영원히 반영되어야 하는 것
    
    - 데이터베이스에 시스템 장애가 발생해도 원래 상태로 복구하는 회복 기능있어야 함

### 무결성

데이터의 정확성, 일관성, 유효성을 유지하는 것

- 데이터베이스에 저장된 데이터 값과 그 값에 해당하는 현실 세계의 실제 값이 일치 하는지에 대한 신뢰가 생김
- 개체 무결성 : 기본키로 선택된 필드는 빈 값을 허용하지 않음
- 참조 무결성 : 서로 참조 관계에 있는 두 테이블의 데이터는 항상 일관된 값을 유지
- 고유 무결성 : 특정 속성에 대해 고유한 값을 가지도록 조건이 주어진 경우 그 속성 값은 모두 고유한 값을 가짐
- NULL 무결성 : 특정 속성 값에 NULL이 올 수 없다는 조건이 주어진 경우 그 속성 값은 NULL이 될 수 없음

## 4. 데이터베이스의 종류

### 관계형 데이터베이스

표 형식의 데이터 저장하는 형태의 데이터베이스

- 언어 : SQL
- MySQL, PostgreSQL, 오라클 등..

MySQL

- 대부분 운영체제와 호환
- 가장 많이 사용하는 데이터베이스
- MySQL 스토리이 엔진 아키텍쳐
    - storage engine
        - 데이터베이스의 심장과도 같은 역할
        - 모듈식 아키텍 처로 쉽게 스토리지 엔진을 바꿀 수 있음
        - 데이터 웨어하우징, 트랜잭션 처리, 고가용성 처리에 강점
    - 커넥터 API, 서비스 계층 → 데이터베이스와 상호작용

PostgreSQL

- VACUUM : 디스크 조각이 차지하는 영역을 회수할 수 있는 장치
- 지정 시간에 복구하는 기능, 로깅, 접근 제어, 중첩된 트랜잭션, 백업 등을 할 수 있음

### NoSQL 데이터베이스

SQL을 사용하지 않는 데이터베이스

ex) MongoDB, redis

MongoDB

- JSON을 통해 데이터 접근
- Binary JSON 형태(BSON)로 데이터 저장
- 스키마를 정해 놓지 않고 데이터를 삽입→ 분석, 로깅 강점
- 도큐먼트를 생성할 때 → 다른 컬렉션에서 중복된 값을 지니기 힘든 유니크한 값인 ObjectID 생성

redis

- 인메모리 데이터베이스
- 키-값 데이터 모델 기반의 데이터베이스
- pub/sub 기능을 통해 채팅 시스템
- 다른 데이터베이스 앞단에 두어 사용하는 캐싱 계층
- 단순한 키-값이 필요한 세션 정보 관리

## 5. 인덱스

인덱스 : 데이터를 빠르게 찾을 수 있는 하나의 장치

찾고자 하는 데이터를 빠르게 찾을 수 있음

### B-트리

인덱스는 보통 B-트리라는 자료 구조로 이루어짐

- 루트 노드, 리프 노드, 브랜치 노드
- 트리 탐색
    - 루트 노드부터 탐색 → 브랜치 노드 → 리프 노드까지 내 려옴
    - 리프노드 도달시 결괏값 반환

### 대수확장성

인덱스 효율적인 이유 : 균형 잡힌 트리 구조와 트리 깊이의 대수확장성 때문

- 대수확장성 : 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것
- 인덱스가 한 깊이씩 증가할 때마다 최대 인덱스 항목의 수는 4배씩 증가

### 인덱스 만드는 방법

MySQL

- 클럿스터형 인덱스
    - 테이블당 하나 인덱스 설정
    - PK옵션으로 기본키 만듬
    - 하나의 인덱스만 생성할 경우 성능 좋음
- 세컨더리 인덱스
    - 기본키로 만들지 않고 unique not null 옵션 붙임
    - create index 명령어 기반 생성

MongoDB

- 도큐먼트를 만들면 자동으로 ObjectID가 형성
- 해당 키가 기본키로 설정
- 세컨더리키도 부가적으로 설정해서 기본키와 세컨더리키를 같이 쓰는 복합 인덱스를 설정 가능

### 인덱스 최적화 기법

1. 인덱스는 비용이다
    
    컬렉션에서 가져와야 하는 양이 많을수록 인덱스를 사용하는 것은 비효율적
    
2. 항상 테스팅하라
    
    인덱스 최적화 기법은 서비스 특징에 따라 달라짐 → 항상 테스팅 하는 것이 중요
    
3. 복합인덱스는 같음, 정렬, 다중값, 카디널리티 순
    
    인덱스 생성 순서 : 같음, 정렬, 다중 값, 카디 널리티 순
    

## 6. 조인의 종류

조인 : 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것

- MySQL : JOIN 쿼리
- MongoDB : lookup 쿼리
    - 연산(lookup)에 대해 관계형 데이터베이스보다 성능이 떨어짐
    - 여러 테이블을 조인하는 작업이 많을 경우 → MongoDB보다는 관계형 데이터베이스 사용

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/17d44586-9433-46b4-8638-62006d0cc246/Untitled.png)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/7307f67a-cfea-4a1e-aac3-fbc4d0907b67/Untitled.png)

### 내부조인

두 테이블간의 교집합

```sql
SELECT * FROM TableA A
INNER JOIN TableB B ON
A.key = B.key
```

### 왼쪽조인

왼쪽 테이블의 모든 행이 결과 테이블에 표기

```sql
SELECT * FROM TableA A 
LEFT JOIN TableB B ON 
A.key = B.key
```

### 내부조인

두 테이블 간에 교집합

```sql
SELECT * FROM TableA A 
LEFT JOIN TableB B ON 
A.key = B.key
```

### 오른쪽 조인

오른쪽 테이블의 모든 행이 결과 테이블에 표기

```sql
SELECT * FROM TableA A 
RIGHT JOIN TableB B ON 
A.key = B.key
```

### 합집합 조인

조인 조건에 만족하지 않는 행까지 모두 표시

```sql
SELECT * FROM TableA A
FULL OUTER JOIN TableB B ON 
A.key = B.key
```

## 7. 조인의 원리

앞서 설명한 조인의 종류는 이 원리를 기반으로 조인을 하는 것

### 중첩 루프 조인

중첩 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법

- 랜덤 접근에 대한 비용이 많이 증가하므로 대용량의 테이블에서는 사 용하지 않음
- 조인할 테이블을 작은 블록으로 나눠서 블록 하나씩 조인 : 블록 중첩 루프 조인

### 정렬 병합 조인

각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인

- 〈,〉등 범위 비교 연산자가 있을 때 사용

### 해시 조인

해시 테이블을 기반으로 조인하는 방법

하나의 테이블이 메모리에 온전히 들어간다면 보통 중첩 루프 조인보다 더 효율적

- 빌드단계
    - 입력 테이블 중 하나를 기반으로 메모리 내 해시 테이블을 빌드하는 단계
    - 바이트가 더 작은 테이블 기반으로 테이블 빌드
- 프로브 단계
    - 레코드 읽기 시작
    - 일치하는 레코드 찾아서 결괏값으로 반환

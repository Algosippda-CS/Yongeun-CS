# 자료구조

자료구조 : 효율적으로 데이터를 관리하고 수정, 삭제, 탐색, 저장할 수 있는 데이터 집합

## 5.1 복잡도

### 시간복잡도

문제를 해결하는데 걸리는 시간과 입력의 함수 관계

알고리즘 로직이 얼마나 오랜 시간 걸리는지 나타낼 때 쓰임

- 빅오 표기법
    - 입력 범위 n을 기준으로 해서 로직이 몇 번 반복되는지 나타내는 것
    - **가장 영향을 많이 끼치는 항**의 상수 인자를 빼고 나머지 항을 없애서 표기
- 존재 이유
    - 효율적인 코드로 개선하는 데 쓰이는 척도
    - O(n^2) : 9초 → O(n) : 3초
- 속도 비교
    - O(n^2)<O(n)<O(log n)<O(1)

### 공간 복잡도

프로그램을 실행시켰을 때 필요로 하는 자원 공간의 양

### 자료구조 시간복잡도

| 자료구조 | 접근 | 탐색 | 삽입 | 삭제 |
| --- | --- | --- | --- | --- |
| 배열 | O(1) | O(n) | O(n) | O(n) |
| 스택 | O(n) | O(n) | O(1) | O(1) |
| 큐 | O(n) | O(n) | O(1) | O(1) |
| 이중 연결 리스트 | O(n) | O(n) | O(1) | O(1) |
| 해시 테이블 | O(1) | O(1) | O(1) | O(1) |
| 이진 탐색 트리 | O(log n) | O(log n) | O(log n) | O(log n) |
| AVL 트리 | O(log n) | O(log n) | O(log n) | O(log n) |
| 레드 블랙 트리 | O(log n) | O(log n) | O(log n) | O(log n) |

## 5.2 선형 자료 구조

: 요소가 일렬로 나열되어 있는 자료 구조

### 연결리스트

데이터를 감싼 노드를 포인터로 연결해서 공간적인 효율성을 극대화시킨 자료구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/84441b3f-b46c-4a75-b3c0-152e8e856a2b/Untitled.png)

prev, next 포인터로 앞뒤 노드 연결

- 싱글 연결 리스트 : next 포인터만 가짐
- 이중 연결 리스트 : next, prev 포인터 가짐
- 원형 이중 연결 리승트 : next, prev을 갖고 마지막 노드의 next 포인터가 헤드 노드를 가리킴
- 추가와 삭제 많이 하는 것은 연결리스트로 하는게 좋음 O(1)

### 배열

- 특징
    - 같은 타입의 변수들로 이루어짐
    - 크기가 정해짐
    - 인접한 메모리 위치에 있는 데이터를 모아놓은 집합
    - 탐색을 많이 하는것은 배열로 하는게 좋음 O(1)
- 랜덤 접근
    - = 직접 접근
    - 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능
- 순차적 접근
    - 데이터를 저장 된 순서대로 검색해야 하는 것

<aside>
💡 **배열과 연결리스트**
`배열`
- 상자를 순서대로 나열한 데이터 구조
- 몇 번째 상자인지만 알면 해당 상자의 요소를 끄집어낼 수 있음
- 탐색 빠름
- 데이터 추가, 삭제 느림

`연결 리스트`
- 상자를 선으로 연결한 형태의 데이터 구조
- 상자 안의 요소를 알기 위해 하나씩 상자 내부를 확인
- 탐색 느림
- 데이터 추가, 삭제 빠름

</aside>

### 벡터

동적으로 요소를 할당할 수 있는 동적 배열

- 컴파일 시점에 개수를 모른다면 벡터 사용
- 중복을 허용/ 순서가 있음/ 랜덤 접근 가능
- 탐색과 맨 뒤의 요소를 삭제하거나 삽입 : O(1)
- 맨 뒤나 맨 앞이 아닌 요소를 삭제하고 삽입 : O(n)

### 스택

- 가장 마지막으로 들어간 데이터가 가장 첫 번째로 나오는 성질(LIFO)
- 삽입 및 삭제O(1), 탐색 O(n)

### 큐

- 먼저 집어넣은 데이터가 먼저 나오는 성질(FIFO)
- 삽입 및 삭제에 0(1), 탐색에 O(n)

## 5.3 비선형 자료 구조

일렬로 나열하지 않고 자료 순서나 관계가 복잡한 구조

ex) 트리, 그래프

### 1. 그래프

정점과 간선으로 이루어진 자료 구조

- 정점과 간선
    - **어떠한 곳**에서 **어떠한 곳**으로 **무언가**를 통해 간다
    - 어떠한 곳 → 정점
    - 무언가 → 간선
- 양방향 간선, 단방향 간선

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/79628fdf-4355-42e6-b66c-435d7e816233/Untitled.png)

- 나가는 간선 : outdegree
- 들어오는 간선 : indegree
- 가중치 : 간선과 정점 사이 드는 비용

### 2. 트리

그래프의 특징처럼 정점과 간선으로 이루어짐

트리 구조로 배열된 일종의 계층적 데이터의 집합

- 특징
    - 부모, 자식 계층 구조 가짐
    - V-1 = E : 노드수 -1 = 간선수
    - 트리 내 어떤 노드와 어떤 노드까지의 경로는 반드시 존재
- 루트 노드
    - 가장 위에 있는 노드
    - 탐색시 루트 노드 중심 탐색
- 내부 노드
    - 루트 노드와 내부 노드 사이에 있는 노드
- 리프 노드
    - 자식이 없는 노드
- 트리의 높이와 레벨

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/f088a0a5-864b-48d0-b8af-30292b4862ac/Untitled.png)

- 깊이 : 특정 노드부터 노드까지 최단 거리
- 높이 : 루트 노드부터 리프 노드까지의거리
- 레벨 : 루트 노드 (0레벨) 다음자식 (1레벨)…
- 서브트리 : 트리 내 하위 집합

### 이진 트리

자식의 노드 수가 두 개 이하인 트리				

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/1a7d878c-8bb8-4512-b100-04b639acd086/Untitled.png)

- 정이진 트리**(full binary tree)**:자식 노드가 0 또는 두 개인 이진 트리
- 완전 이진 트리**(complete binary tree)**:왼쪽에서부터 채워져 있는 이진 트리를 의미
    - 마지막 레벨을 제외하고는 모든 레벨이 완전히 채워져 있음
    - 마지막 레벨의 경우 왼쪽부터 채워져 있음
        
        니다.
        
- 변질 이진 트리**(degenerate binary tree)**:자식 노드가 하나밖에 없는 이진 트리
- 포화 이진 트리**(perfect binary tree)**:모든 노드가 꽉 차 있는 이진 트리
- 균형 이진 트리**(balanced binary tree)**:왼쪽과 오른쪽 노드의 높이 차이가 1 이하인 이진 트리
    - map, set을 구성하는 레드 블랙 트리는 균형 이진 트리 중 하나

### 이진 탐색 트리

- 오른쪽 하위 트리 :  노드 값보다 큰 값의 노드만
- 왼쪽 하위 트리 : 노드 값보다 작은 값의 노드만
- 검색하기 용이
- 평균 : O(logn), 최악 O(n)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/44378b11-3606-4e4a-b177-54a39d98bba0/Untitled.png)

### AVL 트리

최악의 경우 선형적인 트리가 되는 것을 방지하고 스스로 균형을 잡는 이진 탐색 트리

- 두 자식 서브트리의 높이 는 항상 최대 1만큼 차이 남
- 탐색, 삽입, 삭제 : O(logn)
- 균형이 안 맞는 것을 맞추기 위해 트리 일부를 왼쪽 혹은 오른쪽으로 회전 시키며 균형을 잡음

### 레드 블랙 트리

균형 이진 탐색 트리

- 탐색, 삽입, 삭제 : O(logn)
- 빨간색 또는 검은색의 색상을 나타내는 추가 비트를 저장
- 삽입 및 삭제 중에 트리가 균형을 유지하도록 하는 데 사용
- 모든 리프 노드와 루트 노드는 블랙이고 어떤 노드가 레드이면 그 노드의 자식은 반드시 블랙이다

### 3. 힙

이진 트리 기반의 자료 구조

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/c13c2a97-0cdc-4cd6-85f1-e680ee130618/1bf032d0-fd79-4308-9aa7-6d9b226a4dc4/Untitled.png)

- 최대힙
    - 루트 노드에 있는 키는 모든 자식에 있는 키 중 가장 큼
    - 자식 노드와의 관계도 재귀적으로
- 최소힙
    - 루트 노드에 있는 키는 모든 자식에 있는 키 중 최솟값
    - 자식 노드와의 관계도 재귀적으로
- 최대힙 삽입
    - 새로운 노드를 힙의 마지막 노드에 이어서 삽입
    - 부모 노드들과의 크기를 비교하며 교환해서 힙의 성질을 만족
    - 삭제도 마찬가지로 재구성

### 4. 우선순위 큐

우선순위가 높은 요소가 우선 순위가 낮은 요소보다 먼저 제공

- 힙 기반 구현
- greater를 써서 오름차순, less를 써서 내림차순으로 바꿀 수 있음

### 5. 맵

키와 매핑된 값의 조합으로 형성된 자료 구조

ex) 1:”000”, 2:”xxx”

- 레드 블랙 트리 자료 구조를 기반으로 형성, 삽입하면 자동으로 정렬
- map<string, int> 형태로 구현
- clear() : 맵에 있는 모든 요소를 삭제
- size() : map 크기를 구함

### 6. 셋

특정 순서에 따라 고유한 요소를 저장하는 컨테이너

- 중복 요소 x, 희소한 값만 저장하는 자료구조

### 7. 해시 테이블

무한에 가까운 데이터들을 유한한 개수의 해시 값으로 매핑한 테이블

- 삽입, 삭제, 탐색 평균적으로 O(1)
